# introduction-to-quantum-computing_soc-25

At first, we were introduced to the fact that every quantum system is in the form of an abstract setting and thus to perform any operation with the purpose to convert it into a different abstract setting there is NO direct way, means it has to be changed into a linear algebra setting through matrix representations then converted to the algebraic setting which corresponds to the final abstract setting, again through the application of linear algebraic operations. 
Following this we learned about Hilbert spaces, which is a vector space wherein all possible quantum states can exist. Hilbert space is described as “abstract” meaning that any vector in its state space (also known as ket) will remain the same and exist regardless of the basis chosen. Further incase a basis is decided the vector can be represented in the form of a column vector. An inner product( analogous to a dot product in vectors ) is a function that takes 2 vectors as its input and gives out a complex number, its the integration of the product of the conjugate transpose of the first vector, weight factor and the second vector. It follows certain properties such as linearity in the second argument, conjugate symmetry, positive definiteness(inner product of a vector with itself is always greater than or equal to 0(when vector is null)), orthogonality condition(inner product of 2 orthogonal vectors =0), cauchy schwarz inequality, the triangle inequality etc. It is also used for finding norm of a vector as well as its projection on other vector. 
Hilbert space identifies itself on the basis of three conditions; 1) it must satisfy all vector space axioms like additivity, associativity, distributivity, etc. over all complex numbers 2) inner product must be defined on that space 3) every cauchy sequence of vectors in the space should converge to a vector in that space. 
Ahead the concept of dual vector space is introduced, where one more term ‘bra of a vector’ comes into play(in matrix terms(dirac notation) bra of a vector(represented by a row vector) is the conjugate transpose of the ket of a vector(represented by a column vector)). The dual vector ket maps any vector bra to a complex number. Additionally, if a certain ket vector is a basis for vector space V then its corresponding dual vector bra will be the basis for the vector space V* thence both the aforementioned vector spaces have the same dimension. 
An outer product is defined as the function taking input two vectors(one bra and one ket) and giving the output as a matrix(used in projection operator, density matrix etc).  
Operators are functions which can be applied from one vector space to another or in the same vector space and basically represent a linear operator as a matrix once a basis is chosen. Any linear operator is called Hermitian if the matrix of the operator is equal to its dagger(adjoint/ conjugate transpose of the matrix). They also follow properties such as; 1) all eigen values are real 2)eigen vectors corresponding to different eigen values are orthogonal 3) hermitian operators are diagonalizable(through gram schmidt process).
Tensor products is a way where two separate vector spaces(eg vector space V: dimension=m and vector space W: dimension=n) can be combined to form larger vector spaces(VⓧW: dimension=mn) similarly A(nxp) ⓧ B(kxm)= C(nkxpm). The basis of the final vector space(after the tensor product) is the tensor product of the respective basis of the precursor vector spaces. Tensor products are specifically useful while dealing with multi qubit systems. Linear operators can also be applied on tensor spaces. For matrices A and B the kronecker representation(matrix representation of the tensor product) of AⓧB would be matrix B multiplied to each element of A. 
A state vector represents the complete state of the quantum system and is linear superposition of a set of basis vectors(some defined quantum states). The square of coefficients of the respective basis vectors represent the probabilities of the state being purely a basis vector, thence the sum of square of all coefficients should be equal to 1 be it any quantum state(normalization condition). 
Further, gates like X, Y, Z , Hadamard gate  etc. were defined wherein the concept of commutators and anticommutators was introduced which are basically functions of operators.
A system’s state is fully described by a unit vector(two vectors that differ by a global phase difference represent the same system) and when sent through operators undergo unitary transformations(norm remains conserved and this change is reversible(can multiply by the inverse/ dagger of the unitary matrix which caused the initial transformation)) thus the system doesn't move in space but rotates in the Hilbert space along the surface(norm of vector is constant=1). Unitary operators follow the property that the product of unitary operator A with its dagger is equal to identity matrix.
Moreover in the next meet, to better understand operator functions we started with the example of schrodinger's equation and assumed the time dependent unitary transformation to be of a certain exponential form. While substituting this into the equation and in the process of proving the equality we realised a certain way operator functions work(properties of spectral decomposition). Spectral decomposition depicts an operator M(preferably hermitian and/or unitary matrix) in terms of its eigen values and eigen vectors(form an orthonormal set). Also, any normal operator in a vector space is diagonal wrt some orthogonal basis of the vector space.
M=i |i><i| then f(M)= if() |i><i|.
Polar decomposition is a matrix factorization technique that breaks down a matrix A into the product of two matrices: an orthogonal or unitary matrix U(unique of A is invertible) and a positive semi-definite matrix P(always uniquely defined as = root of product of A and A dagger).
Further we were also taught how to find the matrix representation of an operator given that we already have the orthonormal basis for vector space V is |v1⟩,|v2⟩,....,|vm⟩ and that for W is |w1⟩,|w2⟩,....,|wn⟩.  A|vi⟩ = w′ = Aij |wj⟩  thus Aij = ⟨wj|A|vi⟩.
When we have a quantum state and we want to measure a certain property of it(observable) it is represented by an operator A and when we measure this, the only possible outcomes would be the eigen vectors of A . Once the measurement is performed and an eigenvalue is measured, the quantum state "collapses" into the eigenspace corresponding to that eigenvalue(set of all eigen vector that shares the same eigen value). If the eigenspace corresponding to the eigen vector has a dimension 1 then the eigen vector is said to be non degenerate on the other hand if the eigen space is n-dimensional it is said to be n-fold degenerate. 
Quantum measurements are described by a set of measurement operators {Mm} and these operators are defined based on the observables being measured. “M” denotes the observable(property to be measures spin/ energy etc.) while m denotes the possible eigen states( as any state is a superposition of the vector spaces’ eigen states). Hence if I have white light(analogy given to a certain quantum state(normalised)) consisting of VIBGYOR and I want to separate any colour for say green from it, this operator Mm corresponding to green will extract the green light from it but won’t necessarily would be a valid output(or a valid quantum state as it wont be normalised) thence we would have to convert in a form wherein it can be exist as a possible outcome(normalise it in the further step)
∣ψ⟩⇾​​Mm​∣ψ⟩⇾Normalization⇾​∣ψ′⟩
The probability with which the result would be m: p(m)=⟨ψ∣Mm†​Mm​∣ψ⟩
As the sum of probabilities of all possible eigenstates has to be equal to one we derive a relation of the measurement operator through that: mM†mMm =1 
And through this we can finally compute the final state corresponding eigen state m:
 ∣ψ′⟩=Mm​∣ψ⟩⟨ψ∣Mm†​Mm​∣ψ⟩
A projection operator Pm is a special type of operator that is Hermitian (Pm = Pm†) and idempotent (Pm² = Pm). It projects a quantum state onto a specific subspace of the Hilbert space. A projective measurement is a measurement described by a set of orthogonal projection operators {Pm}. Pm is defined as Pm =i=1n|mi⟩⟨mi| where m is an eigen vector that is n-fold degenerate. Through the formula we can observe that Pm chooses eigen vectors(“m” corresponds to that) of any quantum state and kind of superimposes it on the eigen vector space of m. As we know any observable  A can be written as A =i |i><i| using spectral decomposition theorem thence A=i=1nmPm. Further the probability p(m)=⟨ψ|Pm|ψ⟩ and final state  
∣ψ′⟩=Pm​∣ψ⟩⟨ψ∣Pm​∣ψ⟩

 
The further session was focused on understanding the structure and functioning of quantum circuits, the quantum counterparts of classical logic circuits. These circuits use qubits instead of bits and are governed by principles like superposition and entanglement. The session introduced the idea of quantum algorithms, which begin with qubits initialized to the |0⟩ state, followed by a series of unitary gate operations and end with measurements. 
Two primary algorithm families were discussed: those based on the Quantum Fourier Transform, used in Shor’s algorithm for factoring, and Grover’s algorithm for quantum search, both offering significant speedups over classical methods. The basics of single-qubit operations were covered, involving unitary matrices that perform rotations on the Bloch sphere, such as the Pauli gates (X, Y, Z), Hadamard, S, and T gates, and rotation gates like Rx, Ry, and Rz. The Euler decomposition was introduced to show that any single-qubit unitary can be expressed using a sequence of rotations. Controlled operations, like the CNOT gate and its generalizations (controlled-U, Toffoli, and multi-controlled gates), allow conditional logic and are vital for building complex quantum logic. These gates can be constructed using a combination of 1-qubit gates and CNOTs. Measurement, a critical step in quantum circuits, collapses a quantum state to a classical outcome, typically in the computational basis, and plays an essential role in extracting output, applying feedback, and error correction. The concept of universality was introduced to show that a finite set of gates, such as {H, S, T, CNOT}, can approximate any quantum operation, backed by the Solovay–Kitaev theorem which ensures efficient approximation with a polylogarithmic number of gates. 
The circuit model was discussed in terms of cost metrics like gate count, depth, and width, and how quantum gates acting on separate qubits can run in parallel to reduce circuit depth. The model was extended to include variants like mid-circuit measurements, classical control, and ancilla qubits, which, despite differing implementations, are computationally equivalent. Circuit equivalences, transformations through basis changes, and simplifications like expressing rotations through conjugation with Hadamard gates were also explored. 
The Bloch sphere composition formulas were presented to understand how combining rotations leads to new transformations, crucial in gate approximation. The session concluded by emphasizing the practical relevance of these concepts in building efficient, optimized quantum circuits capable of running powerful algorithms beyond classical capabilities.

Then we were intorduced to building and simulating quantum circuits using Qiskit. It started by importing essential Qiskit modules such as QuantumCircuit, AerSimulator, execute, and visualization tools like plot_histogram. A quantum circuit is initialized using QuantumCircuit(n, m), where n is the number of qubits and m is the number of classical bits. 
Various quantum gates are demonstrated and applied to qubits: the x gate (Pauli-X) flips the state of a qubit from |0⟩ to |1⟩ or vice versa, functioning as a quantum NOT gate; the h gate (Hadamard) creates a superposition of |0⟩ and |1⟩, putting the qubit into an equal probability state; and the cx or cnot gate entangles two qubits, flipping the target qubit if the control qubit is in state |1⟩. These gates are used in various combinations to create simple quantum circuits. The measure function is then applied to map the state of each qubit to a classical bit, allowing observation of outcomes in the classical domain. 
To execute the circuit, AerSimulator is used to simulate the quantum backend, and execute(circuit, backend) runs the circuit a specified number of times (shots), storing outcomes. The result object obtained from execution is queried using result.get_counts() to extract the frequencies of different measurement outcomes. 
These outcomes are then visualized using plot_histogram(counts), which gives a bar graph showing how often each possible state occurred during measurement. The section emphasizes how gates transform the state of qubits and how measurement converts quantum information into classical bits, providing a complete workflow from circuit creation to execution and result visualization. 

This hands-on approach helped in understanding how each gate functions individually and in composition, how entanglement and superposition could be created, and how measurements collapse quantum states into classical outcomes that can be interpreted and analyzed.





















